B - (A ∩ B)

```sql
SELECT
	b.*
FROM
	B_table b
LEFT JOIN A_table a ON b.Bid = a.Bid
WHERE
	a.Aid IS NULL

SELECT
	b.*
FROM
	B_table b
WHERE
	b.Bid NOT IN (
		SELECT
			b.Bid
		FROM
			B_table b
		INNER JOIN A_table a ON b.Bid = a.Bid
	)
```
平均分大于80分的学生，并按平均分分数从大到小排列

```sql
SELECT
	t.student_name,
	avg(t.score)
FROM
	course t
GROUP BY
	t.student_id
HAVING
	avg(t.score) > 80
ORDER BY
	avg(t.score) DESC
```

Oracle SQL: Update a table with data from another table

```sql
UPDATE table1 t1
SET (NAME, DESC) = (
	SELECT
		t2. NAME,
		t2. DESC
	FROM
		table2 t2
	WHERE
		t1. ID = t2. ID
)
WHERE
	EXISTS (
		SELECT
			1
		FROM
			table2 t2
		WHERE
			t1. ID = t2. ID
	)

update t1 
set t1.colmun = t2.column
from table t1,table t2
where t1.id = t2.id

UPDATE CS_ORDER o
SET (o.CUSTOMER_ID) = (
	SELECT
		c. ID
	FROM
		CS_CUSTOMER c
	WHERE
		o.CUSTOMER_CODE = c.CUSTOMER_CODE
		and c.company_id = o.company_id
)
WHERE o.CUSTOMER_ID IS NULL
```

MySQL 

```sql
UPDATE a_table a,
 b_table b
SET a. CODE = b. CODE
WHERE
	a.id = b.id
```

数据库的三级模式结构，它包括外模式，概念模式，内模式，有效地组织，管理数据，提高了数据库的逻辑独立性和物理独立性。

在SQL语言中，我们可以使用两个通配符%和_，其中"%"表示0个或多个字符，而"_"则表示一个字符。

数据独立性是指应用程序和数据结构之间相互独立，互不影响。在三层模式体系结构中数据独立性是指数据库系统在某一层次模式上的改变上不会使它的上一层模式也发生改变的能力


1. 概念结构设计。这是数据库设计的第一个阶段，在管理信息系统的分析阶段，已经得到了系统的数据流程图和数据字典，现在要结合数据规范化的理论，用一种数据模型将用户的数据需求明确地表示出来。

概念数据模型是面向问题的模型，反映了用户的现实工作环境，是与数据库的具体实现技术无关的。建立系统概念数据模型的过程叫做概念结构设计。

2. 逻辑结构设计。根据已经建立的概念数据模型，以及所采用的某个数据库管理系统软件的数据模型特性，按照一定的转换规则，把概念模型转换为这个数据库管理系统所能够接受的逻辑数据模型。不同的数据库管理系统提供了不同的逻辑数据模型，如层次模型、网状模型、关系模型等。

3. 物理结构设计。为一个确定的逻辑数据模型选择一个最适合应用要求的物理结构的过程，就叫做数据库的物理结构设计。数据库在物理设备上的存储结构和存取方法称为数据库的物理数据模型。


- 避免活锁： 先来先服务
- 防止死锁： 一次封锁，顺序封锁

1. 活锁

如果事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求，...，T2有可能永远等待，这就是活锁的情形，如图8.4(a)所示。 避免活锁的简单方法是采用先来先服务的策略。


2. 死锁

如果事务T1封锁了数据R1，T2封锁了数据R2，然后T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁。接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁。这样就出现了T1在等待T2，而T2又在等待T1的局面，T1和T2两个事务永远不能结束，形成死锁。

#### 死锁的预防

在数据库中，产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。防止死锁的发生其实就是要破坏产生死锁的条件。预防死锁通常有两种方法：

- 一次封锁法

一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。 一次封锁法虽然可以有效地防止死锁的发生，但也存在问题，一次就将以后要用到的全部数据加锁，势必扩大了封锁的范围，从而降低了系统的并发度。

- 顺序封锁法

顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。 顺序封锁法可以有效地防止死锁，但也同样存在问题。事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁。 可见，在操作系统中广为采用的预防死锁的策略并不很适合数据库的特点，因此DBMS在解决死锁的问题上普遍采用的是诊断并解除死锁的方法。


#### 死锁的诊断与解除

- 超时法

如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但其不足也很明显。一是有可能误判死锁，事务因为其他原因使等待时间超过时限，系统会误认为发生了死锁。二是时限若设置得太长，死锁发生后不能及时发现。

- 等待图法

事务等待图是一个有向图G=(T,U)。 T为结点的集合，每个结点表示正运行的事务；U为边的集合，每条边表示事务等待的情况。若T1等待T2,则T1、T2之间划一条有向边，从T1指向T2。事务等待图动态地反映了所有事务的等待情况。并发控制子系统周期性地（比如每隔1分钟）检测事务等待图，如果发现图中存在回路，则表示系统中出现了死锁。

数据库特点

- 数据结构化
- 数据的共享性高，冗余度低，易扩展
- 数据独立性高
- 数据由DBMS统一管理和控制


在关系模型中,关系完整性主要是指以下三方面：

1. 实体完整性

所谓的实体完整性就是指关系(所谓的关系就是表)的主码不能取空值；
比如学生表的主码通常是取学号为主码

2. 参照完整性

是指参照关系中每个元素的外码要么为空(NULL),要么等于被参照关系中某个元素的主码；
比如今天是9月2日是开学日,大学新生刚来报道,在学生表里,有的学生可能还没来得及分配具体的班,所以这些还未来得及分班的学生教务处可以在学生表里的班级属性取空值NULL(空值代表“不确定”),而哪些已分了班的学生就必须取班级表里的某些属性,比如班级类别,即学生属于哪个班.比如取“软件工程”,”计算机技术应用“等等.
参照关系也称为外键表,被参照关系也称为主键表.

3. 用户定义的完整性

指对关系中每个属性的取值作一个限制(或称为约束)的具体定义.比如 性别属性只能取”男“或”女“ ,再就是年龄的取值范围,可以取值0-130 ,但不能取负数,因为年龄不可能是负数.